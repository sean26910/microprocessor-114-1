//
// GPIO_7seg : counting from 0 to 9999 and display on 7-segment LEDs
//
#include <stdio.h>
#include <stdlib.h>
#include "NUC100Series.h"
#include "MCU_init.h"
#include "SYS_init.h"
#include "LCD.h"
#include "Scankey.h"
#include "Seven_Segment.h"
#include "Draw2D.h"
#include "math.h"
#define R_BAR_X LCD_Xmax-1 // Right-Bar X-position
#define L_BAR_X 0 // Left-Bar  X-position
#define PI 3.1415926
#define X0 84
#define Y0 32
#define SEC_R 20
#define MIN_R 10


enum State{set,run};

volatile enum State st=run;

volatile uint32_t sec=0,min=0,sec_tick=0,flag=1;
volatile uint16_t old_x=X0, old_y=Y0;
volatile uint16_t old_minx=X0, old_miny=Y0;

volatile uint16_t my_min=0,my_sec=0;

unsigned char bmp_Clock[64*8]= 
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0xC0,0x60,0x20,0x30,0xD0,0x98,0x08,0x8C,0x04,0x06,0x06,0x02,0x02,0x02,0x03,0x03,0xF1,0x01,0x13,0x93,0x51,0x31,0x03,0x03,0x02,0x02,0x02,0x06,0x06,0x04,0x0C,0x88,0x18,0x10,0x70,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0xC0,0x60,0x38,0x0C,0x06,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x03,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1D,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x06,0x0C,0x30,0x60,0xC0,0x00,0x00,0x00,0x00,0x00,
	0x00,0xC0,0xF0,0x1E,0x03,0x01,0x02,0x3F,0x00,0x24,0x22,0x21,0x11,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x3B,0x29,0x27,0x00,0x02,0x01,0x07,0x1C,0xF0,0xC0,0x00,
	0xF8,0x9F,0x00,0x00,0x80,0x60,0x20,0xA0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x60,0x20,0xA0,0x60,0x00,0x00,0xBF,0xF8,
	0x1F,0xF9,0x00,0x00,0x01,0x05,0x05,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x05,0x05,0x03,0x00,0x00,0xFD,0x1F,
	0x00,0x03,0x0F,0x78,0xC0,0x80,0x40,0x40,0xB8,0x94,0x94,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x28,0x2C,0xFC,0x00,0x40,0x80,0xE0,0x38,0x0F,0x03,0x00,
	0x00,0x00,0x00,0x00,0x00,0x03,0x06,0x1C,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x10,0x08,0xC8,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x50,0x48,0x68,0xC8,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0x60,0x30,0x1C,0x06,0x03,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x03,0x06,0x04,0x0C,0x1A,0x11,0x10,0x30,0x20,0x60,0x60,0x40,0x40,0x40,0xC0,0xC0,0x80,0x8F,0xD2,0xCA,0x8E,0x80,0xC0,0xC0,0x40,0x40,0x40,0x60,0x60,0x21,0x31,0x11,0x19,0x0A,0x0C,0x04,0x06,0x03,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

void Init_GPIO(void)
{
	GPIO_SetMode(PA, BIT12, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PA, BIT13, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PA, BIT14, GPIO_MODE_OUTPUT);
	PA12=1;
	PA13=1;
	PA14=1;
	
	GPIO_SetMode(PC, BIT12, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PC, BIT13, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PC, BIT14, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PC, BIT15, GPIO_MODE_OUTPUT);
	PC12=1;PC13=1;PC14=1;PC15=1;
}

void RTC_IRQHandler(void)
{
		uint16_t theta_sec,theta_min,newx=X0,newy=Y0,new_minx=X0,new_miny=Y0,i;
		if(st==run)
		{
			sec_tick++;
			if(sec_tick>=8)
			{
				sec = (sec+1)%60;
				sec_tick=0;
				if(sec%15==0)
					min = (min+1)%12;
			}											
		}

		theta_sec = (sec*6+90)%360;
		theta_min = (min*30+90)%360;
	
		newx = X0 - (SEC_R-2)*cos(theta_sec*PI/180);
		newy = Y0 - (SEC_R-2)*sin(theta_sec*PI/180);
	
		new_minx = X0 - (MIN_R-2)*cos(theta_min*PI/180);
		new_miny = Y0 - (MIN_R-2)*sin(theta_min*PI/180);
    
		draw_Line(old_x,old_y,X0,Y0,BG_COLOR,BG_COLOR);
		draw_Line(newx,newy,X0,Y0,FG_COLOR,BG_COLOR);
		
		draw_Line(old_minx,old_miny,X0,Y0,BG_COLOR,BG_COLOR);
		draw_Line(new_minx,new_miny,X0,Y0,FG_COLOR,BG_COLOR);
		
		old_x = newx; old_y = newy; old_minx = new_minx;old_miny=new_miny;
		RTC_CLEAR_TICK_INT_FLAG();	
}

void Init_EXTINT(void)
{
	  // Configure EINT1 pin and enable interrupt by rising and falling edge trigger
    GPIO_SetMode(PB, BIT15, GPIO_MODE_INPUT);
    GPIO_EnableEINT1(PB, 15, GPIO_INT_RISING); // RISING, FALLING, BOTH_EDGE, HIGH, LOW
    NVIC_EnableIRQ(EINT1_IRQn);

    // Enable interrupt de-bounce function and select de-bounce sampling cycle time
    GPIO_SET_DEBOUNCE_TIME(GPIO_DBCLKSRC_LIRC, GPIO_DBCLKSEL_64);
    GPIO_ENABLE_DEBOUNCE(PB, BIT15);
}

void EINT1_IRQHandler(void)
{
	GPIO_CLR_INT_FLAG(PB,BIT15);
    if(st==run)
		{
			st = set;
			PC12=0;
		}
		else
		{
			sec_tick = 0;
			PC12=1;
			st = run;
		}
}

void Init_RTC(void)
{
  S_RTC_TIME_DATA_T sInitTime;

    // Time Setting
    sInitTime.u32Year       = 2015;
    sInitTime.u32Month      = 11;
    sInitTime.u32Day        = 29;
    sInitTime.u32Hour       = 9;
    sInitTime.u32Minute     = 0;
    sInitTime.u32Second     = 0;
    sInitTime.u32DayOfWeek  = RTC_SUNDAY;
    sInitTime.u32TimeScale  = RTC_CLOCK_24;

    RTC_Open(&sInitTime);
    RTC_SetTickPeriod(RTC_TICK_1_8_SEC);
    RTC_EnableInt(RTC_RIER_TIER_Msk);
    NVIC_EnableIRQ(RTC_IRQn);		  
}

int key_release(void)
{
		static int prekey = 0;
		int presentkey = 0,result = 0;
		presentkey = ScanKey();
		CLK_SysTickDelay(1000);
		if(prekey!=0 && presentkey==0)
			result = prekey;
		else
			result = 0;
		prekey = presentkey;
		return result;
}

int32_t main()
{	
		int key,x_cord=52,mode=0;
		char buffer[128];
    Init_GPIO();
		SYS_Init();
		init_LCD();
		clear_LCD();
		OpenKeyPad();
		Init_EXTINT();
		Init_RTC();
		draw_Bmp64x64(x_cord,0,FG_COLOR,BG_COLOR,bmp_Clock);
    while(1)
		{
			key = key_release();
			sprintf(buffer,"%02d:%02d",min,sec);
			printS(0,25,buffer);
			
			if(st==set)
			{
				if(key==1)
					mode=0;
				else if(key==2)
					mode=1;
				switch(key)
				{
					case 4:
						if(mode==0)
							min = (min+5)%12;
						else
							sec = (sec+5)%60;
						break;
					case 5:
						if(mode==0)
							min = (min+10)%12;
						else
							sec = (sec+10)%60;
						break;
					case 7:
						if(mode==0)
							min = (min+7)%12;
						else 
							sec = (sec+55)%60;
						break;
					case 8:
						if(mode==0)
							min = (min+2)%12;
						else
							sec = (sec + 50) % 60;
						break;
				}
			}
			CLK_SysTickDelay(2000);
		}
}
//¥Ø«e³]­p ¨C15ªº­¿¼Æ¸õ¤@®æ
//§U±Ð¥i¯à­nªº ¯uªº15¬í¸õ¤@®æ ¨º´N»Ý­n¦h¤@­Ócounter¨Ó°O¿ý¥Ø«e¶]¤F´X¬í¡Acounter = counter+1 % 15;
