//
// GPIO_7seg : counting from 0 to 9999 and display on 7-segment LEDs
//
#include <stdio.h>
#include <stdlib.h>
#include "NUC100Series.h"
#include "MCU_init.h"
#include "SYS_init.h"
#include "LCD.h"
#include "Scankey.h"
#include "Seven_Segment.h"
#include "Draw2D.h"
#define R_BAR_X LCD_Xmax-1 // Right-Bar X-position
#define L_BAR_X 0          // Left-Bar  X-position

volatile uint8_t u8ADF;
volatile uint16_t X, Y;
//volatile uint8_t  B;

//§Q¥Î¤¤Â_¨Ó§ïÅÜ¼Æªº­È ¦¹ÅÜ¼Æ¤@©w­n³]volatile 

typedef struct
{
	int x,y;
}Cell;

Cell snake[64];
int snake_len = 16;
int dirx=0,diry=0,moveflag = 0,gameover = 0;
int blocked = 0;
int last_dirx = 0, last_diry = 0,score=0;
int food_x,food_y;

void Init_GPIO(void)
{
	GPIO_SetMode(PA, BIT12, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PA, BIT13, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PA, BIT14, GPIO_MODE_OUTPUT);
	PA12=1;
	PA13=1;
	PA14=1;
	
	GPIO_SetMode(PC, BIT12, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PC, BIT13, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PC, BIT14, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PC, BIT15, GPIO_MODE_OUTPUT);
	PC12=1;PC13=1;PC14=1;PC15=1;
}

void ADC_IRQHandler(void)
{
    uint32_t u32Flag;

    // Get ADC conversion finish interrupt flag
    u32Flag = ADC_GET_INT_FLAG(ADC, ADC_ADF_INT);

    if(u32Flag & ADC_ADF_INT) {
        X = ADC_GET_CONVERSION_DATA(ADC, 0);
        Y = ADC_GET_CONVERSION_DATA(ADC, 1);
    }
    ADC_CLR_INT_FLAG(ADC, u32Flag);
}

int key_release(void)
{
		static int prekey = 0;
		int presentkey = 0,result = 0;
		presentkey = ScanKey();
		CLK_SysTickDelay(1000);
		if(prekey!=0 && presentkey==0)
			result = prekey;
		else
			result = 0;
		prekey = presentkey;
		return result;
}

void Init_ADC(void)
{
    ADC_Open(ADC, ADC_INPUT_MODE, ADC_OPERATION_MODE, ADC_CHANNEL_MASK );
    ADC_POWER_ON(ADC);
    ADC_EnableInt(ADC, ADC_ADF_INT);
    NVIC_EnableIRQ(ADC_IRQn);
    ADC_START_CONV(ADC);	
}

void test()
{
	char buffer[128];
	sprintf(buffer,"x=%d  ",X);
	print_Line(0,buffer);
	sprintf(buffer,"y=%d  ",Y);
	print_Line(1,buffer);
}


void update_direction()
{
    int dx = (int)X - 2048;
    int dy = (int)Y - 2048;
    int threshold = 600;
    int ndx = 0, ndy = 0;

    // ???????:????,?????
    if (abs(dx) < threshold && abs(dy) < threshold)
        return;

    // ?????????????(ndx, ndy)
    if (abs(dx) >= abs(dy))
    {
        // ????
        ndx = (dx > 0) ? 2 : -2;
        ndy = 0;
    }
    else
    {
        // ????
        ndx = 0;
        ndy = (dy > 0) ? 2 : -2;
    }

    // ????????(?????):??????
    if (dirx == 0 && diry == 0)
    {
        dirx = ndx;
        diry = ndy;
        return;
    }

    // ??????????????????? ? ??,????? dirx/diry
    if (ndx == -dirx && ndy == -diry)
    {
        return;
    }

    // ????:????
    dirx = ndx;
    diry = ndy;
}


void generate_food()
{
	int i,valid;
	while(1)
	{
		valid = 1;
		food_x = (rand()%64)*2;
		food_y = (rand()%32)*2;
		
		for(i=0;i<snake_len;i++)
		{
			if(snake[i].x == food_x && snake[i].y == food_y)
			{
				valid = 0;
				break;
			}
		}
		if(valid)
			break;
	}
	fill_Rectangle(food_x,food_y,food_x+1,food_y+1,FG_COLOR,BG_COLOR);	
}

void move_snake()
{
    int nx, ny, tailx, taily, i;

    if(gameover) 
		{
			print_Line(0,"hello world");
			return;
		}

		// dir=0 => ????
		if(dirx==0 && diry==0)
				return;

		

    // ???????????????
    nx = snake[0].x + dirx;
    ny = snake[0].y + diry;

    // ????:???????? gameover
    if (nx > 126 || nx < 0 || ny > 62 || ny < 0)
    {
        // ???????????:
        // gameover = 1;
        return;
    }
	
		if(nx==food_x && ny==food_y)
		{
			fill_Rectangle(food_x,food_y,food_x+1,food_y+1,BG_COLOR,BG_COLOR);
			score+=10;
			snake_len++;
			
			for(i=snake_len-1;i>0;i--)
				snake[i] = snake[i-1];
			
			snake[0].x = nx;
			snake[0].y = ny;
			
			fill_Rectangle(nx,ny,nx+1,ny+1,FG_COLOR,BG_COLOR);
			generate_food();
			return;
		}
		
    // ????:???? 1 ?????(0 ??)
    for (i = 1; i < snake_len; i++)
    {
        if (snake[i].x == nx && snake[i].y == ny)
        {
            gameover = 1;
            return;
        }
    }

    // ???????,????
    tailx = snake[snake_len - 1].x;
    taily = snake[snake_len - 1].y;

    // ???????????
    for (i = snake_len - 1; i > 0; i--)
        snake[i] = snake[i - 1];

    // ??????
    snake[0].x = nx;
    snake[0].y = ny;

    // ???????????
    fill_Rectangle(nx, ny, nx + 1, ny + 1, FG_COLOR, BG_COLOR);
    fill_Rectangle(tailx, taily, tailx + 1, taily + 1, BG_COLOR, BG_COLOR);
}

void show_7seg(int i,int score);

void Init_Timer1(void)
{
  TIMER_Open(TIMER1, TMR1_OPERATING_MODE, 200);
  TIMER_EnableInt(TIMER1);
  NVIC_EnableIRQ(TMR1_IRQn);
  TIMER_Start(TIMER1);
}

void TMR1_IRQHandler(void)
{	
    static int num = 3;   
    show_7seg(num, score);

    num--;                
    if (num < 0)
        num = 3;          

    TIMER_ClearIntFlag(TIMER1);
}

int32_t main(void)
{
		int i,counter=0;
    Init_GPIO();
		SYS_Init();
		GPIO_SetMode(PB, BIT11, GPIO_MODE_OUTPUT);
		OpenSevenSegment();
		CloseSevenSegment();
		init_LCD();
		clear_LCD();
		OpenKeyPad();
		Init_ADC();
    Init_Timer1();
		for(i=0;i<snake_len;i++)
		{
			snake[i].x = 46-i*2;
			snake[i].y = 32;
			fill_Rectangle(snake[i].x,snake[i].y,snake[i].x+1,snake[i].y+1,FG_COLOR,BG_COLOR);
			//x0 y0 x1 y1
		}
		generate_food();
    while(1){
      //test();
			ADC_START_CONV(ADC);	
			counter = (counter+1)%25;
			update_direction();
			if(counter == 24)
			{
				move_snake();
			}
			CLK_SysTickDelay(3000);
			
    }
}

void show_7seg(int i,int score)
{
    static int leading = 1;
    int data[4];

    data[3] = score/1000;
    data[2] = (score/100)%10;
    data[1] = (score/10)%10;
    data[0] = score%10;

    if(i == 3)
        leading = 1;

    CloseSevenSegment();

    if(data[i] == 0 && leading && i != 0)
    {
        CloseSevenSegment();   // <<<<<< ?????? ??
        return;
    }

    leading = 0;
    ShowSevenSegment(i, data[i]);
}


//joystick up y to 0,down y to 4096,left x to 0,right x to 4096
