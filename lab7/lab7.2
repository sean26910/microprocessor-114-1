//
// LCD_Graph_Pingpong: draw a circle bouncing around between two bars on LCD
//
// EVB : Nu-LB-NUC140
// MCU : NUC140VE3CN
//
#include <stdio.h>
#include <stdlib.h>
#include "Scankey.h"
#include "Seven_Segment.h"
#include <math.h>
#include "NUC100Series.h"
#include "MCU_init.h"
#include "SYS_init.h"
#include "LCD.h"
#include "Draw2D.h"
#define PIXEL_ON  1
#define PIXEL_OFF 0
#define X0 64       // Circle initial X 
#define Y0 32       // Circle initial Y
#define R_BAR_X LCD_Xmax-1 // Right-Bar X-position
#define L_BAR_X 0          // Left-Bar  X-position
enum State{move,stop};
struct ballstate
{
	enum State state;
	uint16_t x,y,r,rec_stx,rec_sty,rec_endx,rec_endy;
	int movx,movy,dirx,diry;
};

void Init_GPIO(void)
{
	GPIO_SetMode(PA, BIT12, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PA, BIT13, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PA, BIT14, GPIO_MODE_OUTPUT);
	PA12=1;
	PA13=1;
	PA14=1;
	
	GPIO_SetMode(PC, BIT12, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PC, BIT13, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PC, BIT14, GPIO_MODE_OUTPUT);
	GPIO_SetMode(PC, BIT15, GPIO_MODE_OUTPUT);
	PC12=1;PC13=1;PC14=1;PC15=1;
}

void Buzz(int number)
{
	int i;
	for (i=0; i<number; i++) {
      PB11=0; // PB11 = 0 to turn on Buzzer
	  CLK_SysTickDelay(100000);	 // Delay 
	  PB11=1; // PB11 = 1 to turn off Buzzer	
	  CLK_SysTickDelay(100000);	 // Delay 
	}
}

int key_release(void)
{
		static int prekey = 0;
		int presentkey = 0,result = 0;
		presentkey = ScanKey();
		CLK_SysTickDelay(1000);
		if(prekey!=0 && presentkey==0)
			result = prekey;
		else
			result = 0;
		prekey = presentkey;
		return result;
}

void init_structure(struct ballstate *ts)
{
	ts->state = stop;
	ts->x=64;ts->y=60;ts->r=3;
	ts->movx=3;ts->movy=3;ts->dirx=0;ts->diry=0;
	ts->rec_stx = rand()%123;ts->rec_sty = rand()%28;
	ts->rec_endx=ts->rec_stx+5;ts->rec_endy=ts->rec_sty+5;
}


void mode_change(struct ballstate* ts,int key)
{
	int left_x,right_x,up_y,down_y;
	if(ts->state == stop)
	{
		switch(key)
		{
			case 1:
				ts->state = move;
				ts->dirx = -1;
				ts->diry = -1;
			case 3:
				ts->state = move;
				ts->dirx = 1;
				ts->diry = -1;
			case 4:
				ts->state = move;
				ts->dirx = -1;
				ts->diry = 0;
			case 6:
				ts->state = move;
				ts->dirx = 1;
				ts->diry = 0;
			case 7:
				ts->state = move;
				ts->dirx = -1;
				ts->diry = 1;
			case 9:
				ts->state = move;
				ts->dirx = 1;
				ts->diry = 1;
		}
	}
	if(key==5)
	{
		ts->state = stop;
		ts->dirx = 0;
		ts->diry = 0;
	}
	
	if(key==8)
	{
		fill_Rectangle(ts->rec_stx,ts->rec_sty,ts->rec_endx,ts->rec_endy,BG_COLOR,BG_COLOR);
		ts->rec_stx = rand()%123;ts->rec_sty=rand()%28;
		ts->rec_endx=ts->rec_stx+5;ts->rec_endy=ts->rec_sty+5;
		fill_Rectangle(ts->rec_stx,ts->rec_sty,ts->rec_endx,ts->rec_endy,FG_COLOR,BG_COLOR);
	}
	
	if ((ts->x - ts->r) < L_BAR_X)
	{
		Buzz(1);
		ts->dirx=1;  
	}
	else if ((ts->x + ts->r) > R_BAR_X) 
	{
		Buzz(1);
		ts->dirx=-1;
	}
	else if ((ts->y - ts->r) < 0) 
	{
		Buzz(1);
		ts->diry=1;  
	}
	else if ((ts->y + ts->r) > LCD_Ymax)
	{
		Buzz(1);
		ts->diry=-1;
	}
	
	//rectangle collision
	left_x=ts->x - ts->r;right_x=ts->x + ts->r;down_y=ts->y - ts->r;up_y=ts->y + ts->r;
	if ((left_x<=ts->rec_endx)&&(left_x>=ts->rec_stx)&&(left_x<=ts->rec_endy)&&(left_x>=ts->rec_sty))
	{
		fill_Rectangle(ts->rec_stx,ts->rec_sty,ts->rec_endx,ts->rec_endy,BG_COLOR,BG_COLOR);
		ts->state = stop;
		ts->dirx=0;ts->diry=0;
		ts->x=64;ts->y=60;
	}
	else if ((right_x<=ts->rec_endx)&&(right_x>=ts->rec_stx)&&(right_x<=ts->rec_endy)&&(right_x>=ts->rec_sty))
	{
		fill_Rectangle(ts->rec_stx,ts->rec_sty,ts->rec_endx,ts->rec_endy,BG_COLOR,BG_COLOR);
		ts->state = stop;
		ts->dirx=0;ts->diry=0;
		ts->x=64;ts->y=60;
	}
	else if ((down_y<=ts->rec_endx)&&(down_y>=ts->rec_stx)&&(down_y<=ts->rec_endy)&&(down_y>=ts->rec_sty))
	{
		fill_Rectangle(ts->rec_stx,ts->rec_sty,ts->rec_endx,ts->rec_endy,BG_COLOR,BG_COLOR);
		ts->state = stop;
		ts->dirx=0;ts->diry=0;
		ts->x=64;ts->y=60;
	}
	else if ((up_y<=ts->rec_endx)&&(up_y>=ts->rec_stx)&&(up_y<=ts->rec_endy)&&(up_y>=ts->rec_sty))
	{
		fill_Rectangle(ts->rec_stx,ts->rec_sty,ts->rec_endx,ts->rec_endy,BG_COLOR,BG_COLOR);
		ts->state = stop;
		ts->dirx=0;ts->diry=0;
		ts->x=64;ts->y=60;
	}
	
	ts->x = ts->x + ts->dirx*ts->movx;
	ts->y = ts->y + ts->diry*ts->movy;
}

int32_t main (void)
{
	int dirX, dirY;
	int movX, movY,count=0;
	uint16_t r,key;
	uint16_t x, y;
	uint16_t fgColor, bgColor;
	struct ballstate ball;
	init_structure(&ball);
	fill_Rectangle(ball.rec_stx,ball.rec_sty,ball.rec_endx,ball.rec_endy,FG_COLOR,BG_COLOR);
	Init_GPIO();
	SYS_Init();
	GPIO_SetMode(PB, BIT11, GPIO_MODE_OUTPUT);
	OpenSevenSegment();
	CloseSevenSegment();
	init_LCD();
	clear_LCD();
	OpenKeyPad();
	
	
	bgColor = BG_COLOR;
	while(1) {
		 srand(count++);
	   fgColor = FG_COLOR;//draw
	   draw_Circle(x, y, r, fgColor, bgColor); // draw a circle
	   CLK_SysTickDelay(50000); // adjustable delay for vision
     fgColor = BG_COLOR;//erase
	   draw_Circle(x, y, r, fgColor, bgColor); // erase a circle
		 key = key_release();
		 mode_change(&ball,key);
     				
     }
}
